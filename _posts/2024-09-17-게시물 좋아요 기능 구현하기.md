---
title: 게시물 좋아요 기능 구현하기
categories: [스프링, 대용량 트래픽 처리 실습]
tags: [대용량 트래픽]
description: ""
math: true
---

<span class="md-title"> 1. 요구사항 </span>   
<span class="md-content"> **게시물의 좋아요 기능 구현하기** </span>      
   
<span class="md-title"> 2. 기능 구현 </span>    
<span class="md-content"> 위의 요구사항을 고려하여 직접 구현해본 결과는 다음과 같다.</span>   

<span class="md-content"> **1) 좋아요 기능 구현** </span>   
<span class="md-content"> Post테이블에 likeCount 컬럼을 추가하였다. </span>

```sql
ALTER TABLE Post ADD likeCount int
```

<span class="md-content"> 요청시 좋아요를 업데이트하는 결과는 다음과 같다.
<div class="img-box">
<img src="/assets/img/게시물 좋아요 기능 구현하기/postLikeResult.png" width="70%" height="70%" alt="paginationResult">
</div>   

<span class="md-title"> 3. 고민사항 </span>   

<span class="md-sub"> 1) 트랜잭션의 동시성 문제 </span>   
<span class="md-content"> 게시물의 like개수를 올리는 다음 코드를 보자. </span>

```java
  public PostDto increaseLikeCount(Long postId)
  {
    Post post = postRepository.getPostById(postId).orElseThrow(IllegalArgumentException::new);
    post.setLikeCount(post.getLikeCount() + 1);
    return PostDto.fromPost(
        postRepository.update(post).orElseThrow(RuntimeException::new)
    );
  }
```

<span class="md-content"> 게시물 id에 해당하는 게시물을 찾아 게시물의 좋아요 개수를 늘린후에 Update 쿼리를 발생시키는 코드이다. 이는 두 스레드가 동시에 게시물을 조회할 때 업데이트 되는 게시물의 좋아요 수는 1만 증가할 수 있다는 문제점이 있다. 다음의 그림을 보자. </span>   
<div class="img-box">
<img src="/assets/img/게시물 좋아요 기능 구현하기/postLikeDiagram1.png" width="100%" height="100%" alt="paginationResult">
</div>   
<span class="md-content"> 이를 해결하기 위해 아래 2가지 방법을 사용해서 구현해보았다. </span>   

<span class="md-content"> **① 비관적 락 방식** </span>   
<span class="md-content"> 비관적 락 방식은 레코드에 대해 락을 걸어 접근을 제한하는 방식이다. 읽기와 쓰기 모두에 대한 접근을 제한하기 위해서 쓰기락을 사용하여 트랜잭션의 격리성을 보장하였다. 다음은 참고한 쓰기락과 읽기락의 접근 허용 여부를 나타내는 표이다. </span>   
<div class="img-box">
<img src="/assets/img/게시물 좋아요 기능 구현하기/lockAccessTable.png" width="100%" height="100%" alt="paginationResult">
</div>   

```sql
SELECT *
FROM Post
WHERE id=:id 
FOR UPDATE
```

<span class="md-content"> 하지만 비관적 락 방식은 멀티 스레드 환경에서 잠금이 풀릴 때까지 대기하기 때문에 성능 저하가 발생할 수 있다는 단점이 있다. </span>   

<span class="md-content"> **② 낙관적 락 방식** </span>   
<span class="md-content"> 낙관적 락 방식은 충돌이 많이 발생하지 않는다는 가정하에 충돌이 발생한 여부만 확인할 수 있는 방식이다. 이는 version이라는 속성을 추가하여 update시에 version의 속성이 변경되었는지 파악함으로써 변경되었다면 충돌로 판단하여 트랜잭션의 격리성을 보장할 수 있다. </span>   

```sql
UPDATE Post
SET memberId=:memberId,
    contents=:contents,
    createdDate=:createdDate,
    likeCount=:likeCount, 
    version=:version+1 
WHERE id=:id AND version=:version
```

<span class="md-content"> 낙관적 방식을 사용하면 스레드가 대기하지 않으므로 트래픽이 몰릴 경우에 성능저하가 발생하지 않는다( 단순 오류만 반환할 경우 )는 장점이 있지만 오류처리에 대해 직접 구현해야하는 단점이 있다. </span>   

<span class="md-title"> 3. 보완할 점 </span>   

<span class="md-sub"> 1. 회원당 좋아요 기능 제한 </span>   
<span class="md-content"> 위의 기능을 사용하면 회원에 대한 좋아요 수를 제한할 수 없다는 문제점이 발생한다. </span>   

<span class="md-sub"> 2. 락 방식의 성능 제한 </span>   
<span class="md-content"> 락 방식을 사용하므로 Update 쿼리문이 작동할 때 자동으로 레코드에 대한 쓰기 락이 걸리므로 같은 레코드를 필요로 하는 다른 기능에 대해 대기가 발생할 수 있다는 문제점이 발생한다. </span>   

<span class="md-content"> 위의 문제점을 해결하기 위한 방법은 다음 Post에서 다뤄보도록 하겠다. </span>   

<span class="md-refs"> refs:   
"백엔드 개발자를 위한 한 번에 끝내는 대용량 데이터 & 트래픽 처리 초격차 패키지"  [\< fastCampus \>](https://fastcampus.co.kr/)   
</span>
